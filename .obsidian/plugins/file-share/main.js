/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/modals/FileShareModal.ts
var import_obsidian = require("obsidian");
var FileShareModal = class extends import_obsidian.SuggestModal {
  constructor(plugin, socket, friends, file = null) {
    super(plugin.app);
    this.plugin = plugin;
    this.socket = socket;
    this.file = file;
    this.friends = friends;
  }
  getSuggestions(query) {
    return this.friends.filter(
      (friend) => friend.username.toLowerCase().includes(query.toLowerCase())
    );
  }
  renderSuggestion(friend, el) {
    el.createEl("div", { text: friend.username });
  }
  onChooseSuggestion(friend, evt) {
    this.checkOnlineAndSendFile(friend);
  }
  checkOnlineAndSendFile(friend) {
    this.socket.send("checkOnline", { target: friend.publicKey });
    this.socket.getWS().onmessage = (message) => {
      const data = JSON.parse(message.data);
      if (data.type === "checkOnline" && data.target === friend.publicKey) {
        if (data.online) {
          if (this.file != null) {
            this.plugin.fileRequestQueue.addRequest(this.file, friend);
            if (this.plugin.settings.scanSendingFiles) {
              this.plugin.fileTransmitter.scanFileAndSend(this.file, friend);
            }
          }
        } else {
          new import_obsidian.Notice(`${friend.username} is offline at the moment`);
        }
      } else if (data.type === "response") {
        this.plugin.fileRequestQueue.handleResponse(data.id, data.accepted, data.hash);
      }
    };
  }
};

// src/settings/FileShareSettingTab.ts
var import_obsidian3 = require("obsidian");

// src/modals/FriendModal.ts
var import_obsidian2 = require("obsidian");
var FriendModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, index, fileShareSettingTab) {
    super(app);
    this.plugin = plugin;
    this.index = index;
    this.fileShareSettingTab = fileShareSettingTab;
    this.loadModalForm();
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.index === null ? "Add Friend" : "Edit Friend"
    });
    new import_obsidian2.Setting(contentEl).setName("Username").addText((text) => {
      text.setValue(this.username);
      text.onChange((value) => {
        this.username = value;
      });
    });
    new import_obsidian2.Setting(contentEl).setName("Key").addText((text) => {
      text.setValue(this.publicKey);
      text.onChange((value) => {
        this.publicKey = value;
      });
    });
    new import_obsidian2.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Save").setCta().onClick(() => {
        this.saveFriend();
      })
    );
  }
  saveFriend() {
    const username = this.username;
    const publicKey = this.publicKey;
    if (username.length == 0 || publicKey.length == 0) {
      new import_obsidian2.Notice("Please fill out all fields.");
      return;
    } else if (this.plugin.settings.friends.filter((_, idx) => this.index == null || this.index != idx).some((friend) => friend.username === username)) {
      new import_obsidian2.Notice("A friend with this username is already set.");
      return;
    }
    if (this.index === null) {
      this.plugin.settings.friends.push({ username, publicKey });
    } else {
      this.plugin.settings.friends[this.index] = { username, publicKey };
    }
    this.plugin.saveSettings();
    this.close();
    this.fileShareSettingTab.display();
  }
  loadModalForm() {
    this.username = "";
    this.publicKey = "";
    if (this.index !== null) {
      const friend = this.plugin.settings.friends[this.index];
      this.username = friend.username;
      this.publicKey = friend.publicKey;
    }
  }
};

// src/settings/FileShareSettingTab.ts
var DEFAULT_SETTINGS = {
  useCustomSocketUrl: false,
  socketUrl: "wss://ws-fileshare.asss.ist",
  friends: [],
  receiveFolder: "/",
  privateKey: "",
  publicKey: "",
  autoAcceptFiles: false,
  scanSendingFiles: false
};
var FileShareSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("Your key").setDesc("This is your key. Share it with your friends.").addText((text) => {
      text.setValue(this.plugin.settings.publicKey).setDisabled(true);
    }).addExtraButton(
      (button) => button.setIcon("copy").setTooltip("Copy to clipboard").onClick(() => {
        navigator.clipboard.writeText(
          this.plugin.settings.publicKey
        );
        new import_obsidian3.Notice("Key copied to clipboard");
      })
    ).addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Generate new key pair").onClick(async () => {
        const confirmation = confirm(
          "Are you sure you want to generate a new key pair? Your current key will be lost."
        );
        if (confirmation) {
          const { privateKey, publicKey } = await this.plugin.secure.generateKeyPair();
          this.plugin.settings.privateKey = privateKey;
          this.plugin.settings.publicKey = publicKey;
          await this.plugin.saveSettings();
          this.display();
        }
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Receive folder").setDesc("Select the folder where received files will be saved.").addDropdown((drop) => {
      const folders = this.plugin.app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian3.TFolder);
      folders.forEach((folder) => {
        drop.addOption(folder.path, folder.path);
      });
      drop.setValue(this.plugin.settings.receiveFolder);
      drop.onChange(async (value) => {
        this.plugin.settings.receiveFolder = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Auto-accept incoming files").setDesc(
      "Enable to automatically accept incoming files. Attention: There is a potential security risk to do that."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.autoAcceptFiles).onChange(async (value) => {
        let confirmation = true;
        if (!this.plugin.settings.autoAcceptFiles && value) {
          confirmation = confirm(
            "Are you sure you want to activate this option?."
          );
        }
        if (confirmation) {
          this.plugin.settings.autoAcceptFiles = value;
          await this.plugin.saveSettings();
        }
        this.display();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Socket URL").setDesc(
      "Socket URL to exchange files end-to-end encrypted. Only SSL supported."
    ).addToggle(
      (toggle) => toggle.setTooltip("Use custom").setValue(this.plugin.settings.useCustomSocketUrl).onChange(async (value) => {
        if (!value) {
          this.plugin.settings.socketUrl = this.plugin.getDefaultSettings().socketUrl;
        }
        this.plugin.settings.useCustomSocketUrl = value;
        await this.plugin.saveSettings();
        this.display();
      })
    ).addText(
      (text) => text.setPlaceholder("").setValue(this.plugin.settings.socketUrl).setDisabled(!this.plugin.settings.useCustomSocketUrl).onChange(async (value) => {
        this.plugin.settings.socketUrl = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Scan files for first-level embedded links").setDesc(
      "Enhance the ability to automatically scan your outgoing file for first-level embedded links to other documents or images, ensuring they are transmitted alongside the corresponding attachments."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.scanSendingFiles).onChange(async (value) => {
        this.plugin.settings.scanSendingFiles = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Need any help?").setDesc(
      "Feel free to explore the documentation for comprehensive guidance and support."
    ).addButton(
      (button) => button.setButtonText("Open documentation").setCta().onClick(
        () => window.open(
          "https://muckmuck96.github.io/obsidian-file-share/",
          "_blank"
        )
      )
    );
    new import_obsidian3.Setting(containerEl).setName("Add Friend").addButton(
      (button) => button.setButtonText("Add").onClick(() => this.addFriend())
    );
    this.plugin.settings.friends.forEach((friend, index) => {
      new import_obsidian3.Setting(containerEl).setName(`Username: ${friend.username}`).addButton(
        (button) => button.setButtonText("Edit").onClick(() => this.editFriend(index))
      ).addButton(
        (button) => button.setButtonText("Delete").onClick(() => {
          this.plugin.settings.friends.splice(index, 1);
          this.plugin.saveSettings();
          this.display();
        })
      );
    });
  }
  addFriend() {
    const modal = new FriendModal(this.app, this.plugin, null, this);
    modal.open();
  }
  editFriend(index) {
    const modal = new FriendModal(this.app, this.plugin, index, this);
    modal.open();
  }
};

// src/security/Secure.ts
var crypto2 = __toESM(require("crypto"));
var import_obsidian4 = require("obsidian");
var Secure = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async generateKeyPair() {
    const { privateKey, publicKey } = crypto2.generateKeyPairSync("rsa", {
      modulusLength: 2048
    });
    return {
      privateKey: privateKey.export({ type: "pkcs1", format: "pem" }).toString(),
      publicKey: Buffer.from(
        publicKey.export({ type: "pkcs1", format: "pem" }).toString()
      ).toString("base64")
    };
  }
  serializePublicKey(publicKey) {
    return Buffer.from(publicKey, "base64").toString();
  }
  async verifySignature(decryptedFile, receivedSignature, publicKey) {
    const verify = crypto2.createVerify("SHA256");
    verify.update(decryptedFile);
    const verified = verify.verify(
      crypto2.createPublicKey(publicKey),
      receivedSignature,
      "base64"
    );
    return verified;
  }
  async decryptFile(encryptedAesKey, iv, encryptedFile) {
    const aesKey = crypto2.privateDecrypt(
      crypto2.createPrivateKey(this.plugin.settings.privateKey),
      encryptedAesKey
    );
    const decipher = crypto2.createDecipheriv("aes-256-cbc", aesKey, iv);
    return Buffer.concat([
      decipher.update(encryptedFile),
      decipher.final()
    ]);
  }
  generateHash(data) {
    const hmac = crypto2.createHmac(
      "sha256",
      this.plugin.settings.privateKey
    );
    hmac.update(`${data.filename}${data.from}`);
    return hmac.digest("base64");
  }
  async signFile(file) {
    if (!file) {
      new import_obsidian4.Notice("No file selected");
      return null;
    }
    const fileContent = await this.plugin.app.vault.readBinary(file);
    const sign = crypto2.createSign("SHA256");
    sign.update(Buffer.from(fileContent));
    const signature = sign.sign(this.plugin.settings.privateKey, "base64");
    return signature;
  }
  signData(data) {
    const sign = crypto2.createHmac(
      "SHA256",
      this.plugin.settings.privateKey
    );
    sign.update(data);
    return sign.digest("base64");
  }
  async encryptFile(file, friend) {
    if (!file) {
      new import_obsidian4.Notice("No file selected");
      return null;
    }
    const signature = await this.signFile(file);
    const publicKey = this.plugin.secure.serializePublicKey(
      friend.publicKey
    );
    const fileContent = await this.plugin.app.vault.readBinary(file);
    const aesKey = crypto2.randomBytes(32);
    const iv = crypto2.randomBytes(16);
    const cipher = crypto2.createCipheriv("aes-256-cbc", aesKey, iv);
    const encryptedFile = Buffer.concat([
      cipher.update(Buffer.from(fileContent)),
      cipher.final()
    ]);
    const encryptedAesKey = crypto2.publicEncrypt(publicKey, aesKey);
    return {
      file: encryptedFile.toString("base64"),
      aesKey: encryptedAesKey.toString("base64"),
      iv: iv.toString("base64"),
      filename: file.name,
      signature
    };
  }
  isSocketURLSecure() {
    return this.plugin.settings.socketUrl.startsWith("wss://");
  }
};

// src/core/Socket.ts
var import_obsidian5 = require("obsidian");
var Socket = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.setConnectionStatus("disconnected");
  }
  close() {
    this.ws.close();
  }
  send(type, data) {
    const payload = Object.assign({ type }, data);
    this.ws.send(JSON.stringify(payload));
  }
  getWS() {
    return this.ws;
  }
  setConnectionStatus(connectionStatus) {
    this.plugin.connectionStatus.innerText = `FileShare: ${connectionStatus}`;
  }
  verifySocketURL() {
    if (!this.plugin.secure.isSocketURLSecure()) {
      new import_obsidian5.Notice(
        "Socket URL could not be validated for SSL. Using default socket server..."
      );
      this.plugin.settings.socketUrl = this.plugin.getDefaultSettings().socketUrl;
    }
  }
  toggleConnection() {
    if (this.ws.readyState === WebSocket.OPEN) {
      this.ws.close();
      new import_obsidian5.Notice("Closing connection...");
    } else if (this.ws.readyState !== WebSocket.OPEN) {
      this.init();
      new import_obsidian5.Notice("Trying to connect...");
    }
  }
  init() {
    this.verifySocketURL();
    this.ws = new WebSocket(this.plugin.settings.socketUrl);
    this.ws.onopen = () => {
      new import_obsidian5.Notice("FileShare connection opened.");
      this.setConnectionStatus("connected");
      this.send("login", { name: this.plugin.settings.publicKey || "" });
    };
    this.ws.onmessage = (message) => {
      const data = JSON.parse(message.data);
      if (data.sender && this.plugin.settings.friends.some(
        (friend) => friend.publicKey === data.sender
      )) {
        const sender = this.plugin.settings.friends.find(
          (friend) => friend.publicKey == data.sender
        );
        if (data.type == "file") {
          const expectedHash = this.plugin.secure.generateHash(data);
          if (data.hash === expectedHash) {
            this.plugin.fileTransmitter.receiveFile(data);
          }
        } else if (data.type == "request") {
          const accept = this.plugin.settings.autoAcceptFiles || confirm(
            `${sender == null ? void 0 : sender.username} want to sent you: ${data.filename}. Accept it?`
          );
          const hash = accept ? this.plugin.secure.generateHash(data) : "";
          this.send("response", {
            target: data.sender,
            accepted: accept,
            filename: data.filename,
            hash,
            id: data.id
          });
        }
      }
    };
    this.ws.onclose = () => {
      this.setConnectionStatus("disconnected");
      new import_obsidian5.Notice("FileShare connection closed.");
    };
    this.ws.onerror = (error) => {
      console.error("WebSocket error:", error);
      new import_obsidian5.Notice("WebSocket error occurred. Check console for details.");
    };
  }
};

// src/core/FileTransmitter.ts
var import_obsidian6 = require("obsidian");
var FileTransmitter = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async sendFile(file, friend, hash) {
    if (!file) {
      new import_obsidian6.Notice("No file selected");
      return;
    }
    const encryptedFilePayload = await this.plugin.secure.encryptFile(
      file,
      friend
    );
    const payload = Object.assign(
      { sender: this.plugin.settings.publicKey },
      encryptedFilePayload
    );
    this.plugin.socket.send("file", {
      payload,
      target: friend.publicKey,
      hash
    });
    new import_obsidian6.Notice(`File sent to ${friend.username}`);
  }
  async receiveFile(data) {
    if (!data.sender) {
      new import_obsidian6.Notice("Sender not found");
      return;
    }
    const receiveFolder = this.plugin.settings.receiveFolder;
    const filePath = `${receiveFolder}/${data.filename}`;
    const encryptedFile = Buffer.from(data.file, "base64");
    const encryptedAesKey = Buffer.from(data.aesKey, "base64");
    const iv = Buffer.from(data.iv, "base64");
    const decryptedFile = await this.plugin.secure.decryptFile(
      encryptedAesKey,
      iv,
      encryptedFile
    );
    const isVerified = await this.plugin.secure.verifySignature(
      decryptedFile,
      data.signature,
      this.plugin.secure.serializePublicKey(data.sender)
    );
    if (!isVerified) {
      new import_obsidian6.Notice("Signature verification failed. File not saved.");
      return;
    }
    try {
      await this.plugin.app.vault.createBinary(filePath, decryptedFile);
      new import_obsidian6.Notice(`File received and saved to ${filePath}`);
    } catch (error) {
      console.error("Error saving received file:", error);
      new import_obsidian6.Notice("Failed to save the received file.");
    }
  }
  async scanFileAndSend(file, friend) {
    const content = await this.plugin.app.vault.read(file);
    const links = content.match(/\[\[(.*?)\]\]/g);
    if (!links) {
      return;
    }
    links.forEach((link) => {
      const fileName = link.replace(/\[\[(.*?)\]\]/g, "$1");
      const linkedFile = this.plugin.app.metadataCache.getFirstLinkpathDest(
        fileName,
        file.path
      );
      if (linkedFile) {
        this.plugin.fileRequestQueue.addRequest(linkedFile, friend);
      }
    });
  }
};

// src/core/FileRequestQueue.ts
var import_obsidian7 = require("obsidian");
var FileRequestQueue = class {
  constructor(sendFileMethod, plugin) {
    this.queue = /* @__PURE__ */ new Map();
    this.sendFileMethod = sendFileMethod;
    this.plugin = plugin;
  }
  addRequest(file, recipient) {
    const requestId = this.generateRequestId();
    const request = {
      id: requestId,
      file,
      recipient
    };
    this.queue.set(requestId, request);
    this.sendIFileRequest(request);
  }
  handleResponse(requestId, accepted, hash) {
    const request = this.queue.get(requestId);
    if (request) {
      if (accepted) {
        new import_obsidian7.Notice(`File request accepted by ${request.recipient.username}`);
        this.sendFileMethod(request.file, request.recipient, hash).then(() => {
          this.queue.delete(requestId);
        }).catch((error) => {
          console.error("Error sending the file:", error);
        });
      } else {
        new import_obsidian7.Notice(`File request declined by ${request.recipient.username}`);
        this.queue.delete(requestId);
      }
    }
  }
  generateRequestId() {
    return crypto.randomUUID();
  }
  sendIFileRequest(request) {
    var _a, _b, _c;
    const requestData = JSON.stringify({
      type: "request",
      target: request.recipient.publicKey,
      filename: (_a = request.file) == null ? void 0 : _a.name
    });
    const dataSign = this.plugin.secure.signData(requestData);
    this.plugin.socket.send("request", {
      target: request.recipient.publicKey,
      filename: (_b = request.file) == null ? void 0 : _b.name,
      signature: dataSign,
      id: request.id
    });
    new import_obsidian7.Notice(
      `Request sent to ${request.recipient.username} for file ${(_c = request.file) == null ? void 0 : _c.name}`
    );
  }
};

// src/main.ts
var FileSharePlugin = class extends import_obsidian8.Plugin {
  async onload() {
    await this.loadSettings();
    this.secure = new Secure(this);
    this.app.workspace.onLayoutReady(async () => {
      if (!this.settings.privateKey || !this.settings.publicKey) {
        const { privateKey, publicKey } = await this.secure.generateKeyPair();
        this.settings.privateKey = privateKey;
        this.settings.publicKey = publicKey;
        await this.saveSettings();
      }
    });
    this.connectionStatus = this.addStatusBarItem();
    this.socket = new Socket(this);
    this.socket.init();
    this.fileTransmitter = new FileTransmitter(this);
    this.fileRequestQueue = new FileRequestQueue(this.fileTransmitter.sendFile, this);
    this.addRibbonIcon("refresh-cw", "Toggle connection", () => {
      this.socket.toggleConnection();
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", this.onFileMenu.bind(this))
    );
    this.addSettingTab(new FileShareSettingTab(this.app, this));
  }
  onunload() {
    this.socket.close();
  }
  getDefaultSettings() {
    return DEFAULT_SETTINGS;
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onFileMenu(menu, file) {
    if (file instanceof import_obsidian8.TFile) {
      menu.addItem((item) => {
        item.setTitle("Send to ...").setIcon("paper-plane").onClick(() => {
          new FileShareModal(
            this,
            this.socket,
            this.settings.friends,
            file
          ).open();
        });
      });
    }
  }
};
var main_default = FileSharePlugin;

/* nosourcemap */